**Тестовое задание** 

Дано: гипотетическая децентрализованная система, каждый компонент которой
является микросервисом, а общение между компонентами инфраструктуры происходит
по API.  

Ваша задача: создать прототип микросервиса (назовем его “наносервис”),
обеспечивающий доставку сообщений другим микросервисам, входящим в состав
системы. Микросервис является брокером. Его задача - получать сообщения из внешних
источников и доставлять их своим подписчикам.  

Приложение должно быть обладать следующими возможностями:  
● подписка на topic (если такого топика еще нет, то он создается);  
● доставка полученного сообщения всем подписчикам из topic-ов, указанных в
сообщении.  

Сообщение приходит из абстрактного внешнего источника. Фактическая
реализация приема сообщений откуда-то извне не требуется, сообщения можно
генерировать случайным образом. Подписчиков может быть много (тысячи),
подписываются и отписываются они постоянно. Сообщений тоже много (сотни в единицу
времени). Реализовывать полноценную работу с сетью не обязательно, достаточно
простого интерфейса для взаимодействия подписчиков с разрабатываемым
микросервисом.  

Структуру и формат входящих запросов и ответов, а также потребность в каких-то
дополнительных параметрах, необходимых для функционирования сервиса, оставляем
на ваше усмотрение.  

Язык реализации - Java (версия языка: 8 или выше).  

Необходимо прислать: код системы, инструкцию для развертывания и запуска,
любые другие сопроводительные документы на ваше усмотрение (структура и описание
API, какая-то иная документация и т.п.).  
Сервис не должен осуществлять фактическую прием и отправку сообщений в
сервисы! Нам не принципиальна реализация сетевого взаимодействия, мы в первую
очередь хотим увидеть реализацию конкурентного доступа к данным.  

Написанный вами код не будет работать в “продакшене”. Нам необходимо оценить
имеющиеся у вас навыки программирования и общий подход к дизайну подобных систем.  

Срок выполнения: 2-3 дня.

**Комментарии по решению**
  
* Т.к. сетевое взаимодействие реализовывать не нужно - то все взаимодействие
InMemoryBroker'a через stub ISender.  
* Запускать, кроме тестов, нечего. Хотел добавить тест на корректную работу многопоточной логики, где 
в цикле бы много раз подписывались-отписывались и отправляли сообщения, и запустить его на час, но не успел.  
* Странные копирования Set'a в методах InMemoryBroker#subscribe, 
InMemoryBroker#unsubscriber нужны, т.к. remappingFunction может вызываться несколько раз, 
поэтому если Set не копировать, мы можем отписаться несколько раз от одного топика при 
одном вызове unsubscribe.  
* IBroker#send возвращает boolean, чтобы отправитель мог убедиться, что сообщение 
всем текущим подписчикам доставлено. Можно возвращать подробный результат 
(Map'a подписчик -> результат доставки). Можно сделать асинхронный вариант и возвращать Future, чтобы
не блокировать поток, который вызывает IBroker#send. Текущая реализация выбрана как самая простая. 
* Сообщения подписчикам отправляются асинхронно, поэтому, например, мы можем вызвать InMemoryBroker#send, когда 
подписчик подписан, а сообщение отправится ему, когда он уже отписан. Можно сделать так, чтобы подписка
проверялась при непосредственной отправке или настраивать это в Message. Текущая реализация выбрана как 
самая простая. 
* Очередь сообщений держится в памяти, при падении все теряем. Можно сохранять на диск в какую-нибудь БД, 
но тогда придется решать проблему с транцакционной посылкой и update'ом в БД. Сейчас для простоты предполагается, 
что Message'и идемпотентны и отправители сами контролируют доставку. Можно добавить в Message id, отправитель
тогда будет ждать ACK в другом топике от получателя. Id Message'a нужно просто для логгирования и отслеживания
запросов в распределенной системе. 
* Можно добавить логику перепосылки (retry'ев), количество попыток можно задавать в Message'e. Возможно, 
тогда придется добавить какую-нибудь увеличивающийся timeout между попытками, чтобы не заDDoSить получателя. Для 
простоты сейчас предполагается, что retry'ями управляет отправитель. 
* Мониторинг (размера очереди пула) осуществляется через логи. 

